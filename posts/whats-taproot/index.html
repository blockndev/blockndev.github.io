<!DOCTYPE html>
<html lang="ru">
<meta charset="utf-8">
<title>Taproot: что это и зачем он нужен | Блокчейн &amp; Разработка</title>
<link rel="icon" href="/favicon.ico">
<meta name="generator" content="Hugo 0.70.0-DEV" />
<meta name="description" content="Блог о разработке и блокчейн-технологиях. Код, сети, паранойя.">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://blockndevcomcss/index.css">
<link rel="stylesheet" href="https://blockndevcomcss/classes.css">
<link rel="canonical" href="https://blockndevcom/posts/whats-taproot/">
<link rel="alternate" type="application/rss+xml" href="" title="Блокчейн &amp; Разработка">

<body>

<header class="icons">
  <i class="col-1">&nbsp;</i>
  
    <a class="col-1" href="https://blockndevcom">Блокчейн &amp; Разработка</a>
  
  
    <nav class="col-1 navigation">
    
      <a href="https://t.me/blockndev" >
        
          
          
          <span ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"/></svg></span>
          <span class="hidden">Telegram</span>
        
      </a>
    
      <a href="mailto:me@jeiwan.ru" >
        
          
          
          <span ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg></span>
          <span class="hidden">Mail</span>
        
      </a>
    
      <a href="https://github.com/Jeiwan" >
        
          
          
          <span ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
          <span class="hidden">Github</span>
        
      </a>
    
      <a href="/index.xml" >
        
          
          
          <span ><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg></span>
          <span class="hidden">Subscribe</span>
        
      </a>
    
    </nav>
  
</header>

<article>
  <header>
    <a href="https://blockndevcom/categories/%D0%B1%D0%B8%D1%82%D0%BA%D0%BE%D0%B8%D0%BD/">БИТКОИН</a>, <a href="https://blockndevcom/categories/%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F/">КРИПТОГРАФИЯ</a><h1>Taproot: что это и зачем он нужен</h1>
    <time datetime="2020-02-18T00:00:00Z">18 February 2020</time>
  </header>
  <p>(Этот пост — часть большого паззла. Дописав его я понял, что нужно было бы написать вводный пост по криптографии и некоторым важным механикам. Буду раскрывать тему постепенно.)</p>
<p>P2SH-транзакции (оплата на хэш скрипта), по сути, позволяют создавать смарт-контракты на Биткоине (хоть они и способны лишь проверять права доступа к биткам). Но по сравнению с обычным переводом битков у этого способа есть существенный недостаток: чтобы вывести битки с хэша скрипта, нужно раскрыть весь код скрипта, т. к. у ноды должна быть возможность взять хэш от кода скрипта и сравнить его с хэшем, который был записан в выходе предыдущей транзакции. Это серьёзный удар по анонимности: мало того, что раскрывается сам факт оплаты на скрипт, так ещё и раскрывается сам скрипт, в который часто заносятся адреса других участников транзакции. <strong>Taproot призван исправить эту ситуацию, сделав P2SH-транзакции неотличимыми от P2PKH и избавив от необходимости раскрывать код скрипта</strong>. Но не все так радужно, у новой механики есть и недостатки.</p>
<p>Taproot кардинальным образом меняет способ организации кода в Биткоин-скриптах. Теперь, если код содержит несколько логических веток (т. е. содержит операторы IF/ELSE/ENDIF), то каждая логическая ветка становится листом в дереве Меркла. (Дерево Меркла это обычное бинарное дерево, в котором листья хранят хэши данных, а узлы — хэши от сложенных значений дочерних узлов.) Если точнее: скрипт разбивается на несколько частей (каждая часть — отдельная логическая ветка), в листьях дерева записываются хэши от этих скриптов-веток, и дальше от этих листьев строится дерево. Хэш из корня такого дерева дальше используется для построения адреса, на который производится перевод. Само дерево нигде не хранится и не публикуется в блокчейне при расходовании битков.</p>
<p>Но само по себе такое скриптовое дерево это ещё не Taproot. <strong>Taproot это криптографическая схема, которая позволяет создать публичный ключ, владение которым может быть проверено двумя способами: подписью (стандартный и всем нам известный сценарий) или проверкой алгоритма создания этого ключа</strong>. (Автор этой схемы, кстати, небезызвестный Gregory Maxwell.) Taproot в связке со скриптовым деревом позволяет создать такой публичный ключ, который будет соответствовать либо:</p>
<ol>
<li>Одному листу скриптового дерева, который (лист) был выбран заранее перед созданием ключа. Чтобы вывести биткоины, нужно сделать подпись, используя хэш этого листа в качестве приватного ключа. <strong>Этот способ и является самым анонимным в алгоритме Taproot.</strong> Вы переводите на публичный ключ и предоставляете подпись, когда выводите с него. Но такой вариант возможен только для одного листа из дерева, т. е. только для одной логической ветки скрипта. Поэтому тут нужно выбирать ветку, которая в вашем скрипте будет использоваться чаще остальных.</li>
<li>Любому другому листу, для которого вы раскроете: код скрипта, путь в дереве, правильные входные параметры. Этот способ используется для всех остальных логических веток, и он менее анонимен. Не смотря на это, он все равно лучше чем P2SH, т. к . вы раскрываете только часть скрипта.</li>
</ol>
<p>Формула создания ключа-адреса выглядит так:
<code>Q = P + hash(P || treeRoot)•G</code></p>
<p><code>Q</code> — Taproot-адрес, на который переводятся битки. (Как видно, в формуле не участвует приватный ключ, т. е. публичный ключ создаётся не из приватного — почему такое возможно, разберём позже.) <code>P</code> — некоторый публичный ключ, который уникален для каждого скрипта и для которого известен приватный ключ. <code>treeRoot</code> — хэш из корня скриптового дерева. <code>hash</code> — функция хеширования (SHA-256). <code>||</code> — конкатенация, <code>•</code> — операция умножения по модулю, которая используется для получения публичного ключа из приватного.</p>
<p>Получается вот что:</p>
<ol>
<li>Берём хэш листа, соответствующего логической ветке, которая, как мы считаем, будет использоваться чаще всего. Используем этот хэш в качестве приватного ключа (они оба имеют одинаковый размер — 32 байта) и считаем соответствующий ему публичный ключ. Получаем пару p, P.</li>
<li>Складываем (операция ||) P с хэшем из корня скриптового дерева.</li>
<li>Хэшируем. Получаем 32-байтный хэш, который опять используем в качестве приватного ключа (пусть будет x) и для которого также находим публичный (операция <code>hash(...)•G</code>). Получаем публичный ключ X.</li>
<li>Складываем ключи P и X. Это возможно, потому что публичные ключи это точки на эллиптической кривой.</li>
<li>Получаем публичный ключ Q. Соответствующий ему приватный ключ можно получить, если сложить приватные ключи p и x (это свойство называется гомоморфизм, и мы его ещё не раз будем разбирать).</li>
</ol>
<p>Отправляем на Q биткоины. Как потом их вывести с такого адреса? Есть два способа:</p>
<ol>
<li>Предоставить подпись, сделанную приватным ключом q. Зная приватный ключ p и посчитав приватный ключ x, их нужно сложить, и получится ключ q. Приватный ключ p знает только тот, кто знает хэш корня дерева (а значит и весь скрипт) и скрипт, который был записан в ветке, которая используется по-умолчанию (шаг 1 из предыдущего списка).</li>
<li>Воссоздать ключ Q. Зная P, скрипт-ветку, его входные параметры, путь до него в дереве, можно посчитать хэш корня дерева и воспроизвести Q. В новой транзакции вам нужно будет передать все эти данные, и нода сама посчитает Q и сравнит с Taproot-адресом, который был записан в предыдущей транзакции. Входные параметры скрипта должны быть верными, т. е. скрипт должен завершиться успешно.</li>
</ol>
<p>Вот, в общем-то, и всё.</p>
<p>Получается, что скрипты в открытом виде почти полностью убираются из блокчейна Биткоина, но при этом возрастает нагрузка и ответственность на кошельки и сторонние приложения, т. к. теперь именно им нужно реализовывать вот эти сложные криптографические механики.</p>

</article>



</body>

</html>
