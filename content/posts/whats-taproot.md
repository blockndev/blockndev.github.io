---
title: "Taproot: что это и зачем он нужен"
date: 2020-02-18T00:00:00+00:00
categories: [Биткоин, Криптография]
---

(Этот пост — часть большого паззла. Дописав его я понял, что нужно было бы написать вводный пост по криптографии и некоторым важным механикам. Буду раскрывать тему постепенно.)

P2SH-транзакции (оплата на хэш скрипта), по сути, позволяют создавать смарт-контракты на Биткоине (хоть они и способны лишь проверять права доступа к биткам). Но по сравнению с обычным переводом битков у этого способа есть существенный недостаток: чтобы вывести битки с хэша скрипта, нужно раскрыть весь код скрипта, т. к. у ноды должна быть возможность взять хэш от кода скрипта и сравнить его с хэшем, который был записан в выходе предыдущей транзакции. Это серьёзный удар по анонимности: мало того, что раскрывается сам факт оплаты на скрипт, так ещё и раскрывается сам скрипт, в который часто заносятся адреса других участников транзакции. **Taproot призван исправить эту ситуацию, сделав P2SH-транзакции неотличимыми от P2PKH и избавив от необходимости раскрывать код скрипта**. Но не все так радужно, у новой механики есть и недостатки.

Taproot кардинальным образом меняет способ организации кода в Биткоин-скриптах. Теперь, если код содержит несколько логических веток (т. е. содержит операторы IF/ELSE/ENDIF), то каждая логическая ветка становится листом в дереве Меркла. (Дерево Меркла это обычное бинарное дерево, в котором листья хранят хэши данных, а узлы — хэши от сложенных значений дочерних узлов.) Если точнее: скрипт разбивается на несколько частей (каждая часть — отдельная логическая ветка), в листьях дерева записываются хэши от этих скриптов-веток, и дальше от этих листьев строится дерево. Хэш из корня такого дерева дальше используется для построения адреса, на который производится перевод. Само дерево нигде не хранится и не публикуется в блокчейне при расходовании битков.

Но само по себе такое скриптовое дерево это ещё не Taproot. **Taproot это криптографическая схема, которая позволяет создать публичный ключ, владение которым может быть проверено двумя способами: подписью (стандартный и всем нам известный сценарий) или проверкой алгоритма создания этого ключа**. (Автор этой схемы, кстати, небезызвестный Gregory Maxwell.) Taproot в связке со скриптовым деревом позволяет создать такой публичный ключ, который будет соответствовать либо:
1. Одному листу скриптового дерева, который (лист) был выбран заранее перед созданием ключа. Чтобы вывести биткоины, нужно сделать подпись, используя хэш этого листа в качестве приватного ключа. **Этот способ и является самым анонимным в алгоритме Taproot.** Вы переводите на публичный ключ и предоставляете подпись, когда выводите с него. Но такой вариант возможен только для одного листа из дерева, т. е. только для одной логической ветки скрипта. Поэтому тут нужно выбирать ветку, которая в вашем скрипте будет использоваться чаще остальных.
2. Любому другому листу, для которого вы раскроете: код скрипта, путь в дереве, правильные входные параметры. Этот способ используется для всех остальных логических веток, и он менее анонимен. Не смотря на это, он все равно лучше чем P2SH, т. к . вы раскрываете только часть скрипта.

Формула создания ключа-адреса выглядит так:
`Q = P + hash(P || treeRoot)•G`

`Q` — Taproot-адрес, на который переводятся битки. (Как видно, в формуле не участвует приватный ключ, т. е. публичный ключ создаётся не из приватного — почему такое возможно, разберём позже.) `P` — некоторый публичный ключ, который уникален для каждого скрипта и для которого известен приватный ключ. `treeRoot` — хэш из корня скриптового дерева. `hash` — функция хеширования (SHA-256). `||` — конкатенация, `•` — операция умножения по модулю, которая используется для получения публичного ключа из приватного.

Получается вот что:
1. Берём хэш листа, соответствующего логической ветке, которая, как мы считаем, будет использоваться чаще всего. Используем этот хэш в качестве приватного ключа (они оба имеют одинаковый размер — 32 байта) и считаем соответствующий ему публичный ключ. Получаем пару p, P.
2. Складываем (операция ||) P с хэшем из корня скриптового дерева.
3. Хэшируем. Получаем 32-байтный хэш, который опять используем в качестве приватного ключа (пусть будет x) и для которого также находим публичный (операция `hash(...)•G`). Получаем публичный ключ X.
4. Складываем ключи P и X. Это возможно, потому что публичные ключи это точки на эллиптической кривой.
5. Получаем публичный ключ Q. Соответствующий ему приватный ключ можно получить, если сложить приватные ключи p и x (это свойство называется гомоморфизм, и мы его ещё не раз будем разбирать).

Отправляем на Q биткоины. Как потом их вывести с такого адреса? Есть два способа:
1. Предоставить подпись, сделанную приватным ключом q. Зная приватный ключ p и посчитав приватный ключ x, их нужно сложить, и получится ключ q. Приватный ключ p знает только тот, кто знает хэш корня дерева (а значит и весь скрипт) и скрипт, который был записан в ветке, которая используется по-умолчанию (шаг 1 из предыдущего списка).
2. Воссоздать ключ Q. Зная P, скрипт-ветку, его входные параметры, путь до него в дереве, можно посчитать хэш корня дерева и воспроизвести Q. В новой транзакции вам нужно будет передать все эти данные, и нода сама посчитает Q и сравнит с Taproot-адресом, который был записан в предыдущей транзакции. Входные параметры скрипта должны быть верными, т. е. скрипт должен завершиться успешно.

Вот, в общем-то, и всё.

Получается, что скрипты в открытом виде почти полностью убираются из блокчейна Биткоина, но при этом возрастает нагрузка и ответственность на кошельки и сторонние приложения, т. к. теперь именно им нужно реализовывать вот эти сложные криптографические механики.